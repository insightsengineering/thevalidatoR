---
title: "Validation Report"
subtitle: "`r sprintf('%s (v%s)', (dcf <- read.dcf(file.path(params$pkg_dir, 'DESCRIPTION')))[,'Package'], dcf[,'Version'])`"
output:
  - "pdf_document"
params:
  pkg_dir: "`r normalizePath(Sys.getenv('INPUT_REPORT_PACKAGE_DIR', '.'))`"
---

```{r, include = FALSE}
options(width = 80L, covr.record_tests = TRUE)
remotes::install_local(
  params$pkg_dir,
  force = TRUE,
  quiet = TRUE,
  INSTALL_opts = "--with-keep.source"
)
library(magrittr)
library(knitr)
knitr::opts_chunk$set(
  width = 80L,
  comment = ""
)
```

# Execution Info

## System Info

```{r execution_info, echo = FALSE}
kable(data.frame(
  Field = c("OS", "Platform", "System", "Execution Time"),
  Value = c(
    sessionInfo()$running,
    R.version$platform,
    R.version$system,
    format(Sys.time(), tz = "UTC", usetz = TRUE)
  )))
```

## Version Control

```{r version_control, echo = FALSE}
# find .git dir containing the package directory
gd <- system(
  sprintf("cd '%s' && git rev-parse --absolute-git-dir", params$pkg_dir),
  intern = TRUE
)
# define reused git args to be sure we're picking up the right git info
gd <- sprintf("--git-dir='%s'", gd)
wt <- sprintf("--work-tree='%s'", params$pkg_dir)
kable(data.frame(
  Field = c("branch", "commit `SHA1`", "commit date"),
  Value = c(
    system2("git", list(gd, wt, "rev-parse", "--abbrev-ref", "HEAD"), stdout = TRUE),
    system2("git", list(gd, wt, "rev-parse", "HEAD"), stdout = TRUE),
    system2("git", list(gd, wt, "show", "-s", "--format=%ci", "HEAD"), stdout = TRUE)
  )))
```

## Session Info

```{r session_info, echo = TRUE, eval = TRUE}
sessionInfo()
capabilities()
```

# Metric based assessment

```{r riskmetric, echo = FALSE, eval = TRUE}
params$pkg_dir %>%
  riskmetric::pkg_ref() %>%
  riskmetric::pkg_assess() %>%
  purrr::map(1)  %>% 
  lapply(as.character) %>%
  tibble::enframe() %>% 
  tidyr::unnest(cols = dplyr::everything()) %>%
  dplyr::filter(name != "r_cmd_check") %>%
  # add labels
  dplyr::left_join(
    lapply(riskmetric::all_assessments(), attributes) %>%
      purrr::map_df(tibble::as_tibble),
    by = c("name" = "column_name")
  ) %>%
  dplyr::select(Metric = label, Status = value) %>%
  #table
  kable(
    caption = "Metrics assessed by the R package riskmetric"
  )
```





# Testing

## `R CMD check`

```{r r_cmd_check, echo = FALSE, eval = TRUE}
rcmdcheck_results <- rcmdcheck::rcmdcheck(
  params$pkg_dir,
  args = c(
    "--timings",             # include execution times in output
    "--no-build-vignettes",  # run vignette code, but disable pdf rendering
    "--no-manual"            # disable pdf manual rendering
  ),
  quiet = TRUE
)

cat(rcmdcheck_results$stdout)
cat(rcmdcheck_results$stderr)
```

## Testing Coverage

```{r coverage, echo = FALSE, eval = TRUE}
covr_results <- covr::package_coverage(params$pkg_dir)
covr_results
```

## Traceability

```{r traceability, echo = FALSE, eval = TRUE}
if (require("covtracer", quietly = TRUE)) {
  covtracer_df <- test_trace_df(covr_results)
  covtracer_df$filename <- basename(covtracer_df$filepath)
  
  covtracer_df %>%
    dplyr::filter(!doctype %in% c("data", "class")) %>%  # ignore objects without testable code
    dplyr::select(test_name, file) %>%
    dplyr::filter(!duplicated(.)) %>%
    dplyr::arrange(file) %>%
    kable(
        caption = "Tracebility matrix mapping unit tests to documented behaviours."
    )

  covtracer_df %>%
    dplyr::filter(!doctype %in% c("data", "class")) %>%  # ignore objects without testable code
    dplyr::select(test_name, count, alias, file) %>%
    dplyr::filter(is.na(count)) %>%
    dplyr::arrange(alias) %>%
    kable(
        caption = "Untested behaviours: documentation that is not covered by any test."
    )

  covtracer_df %>%
    dplyr::filter(!doctype %in% c("data", "class")) %>%  # ignore objects without testable code
    dplyr::select(direct, alias) %>%
    dplyr::group_by(alias) %>%
    dplyr::summarize(any_direct_tests = any(direct, na.rm = TRUE)) %>%
    dplyr::arrange(alias)
    kable(
        caption = "Granularity of unit tests: directly tested functions."
    )

} else {
  cat("{covtracer} not available to produce a traceability matrix")
}
```
